@()(implicit request: RequestHeader, messages: Messages)

@articulos.articleLayout("Escalabilidad con Message Passing", "Caso de Estudio", "18 Nov 2025", Seq("Mensajer√≠a", "Distribuci√≥n", "Escalabilidad")) {
    <div class="article-body">
        <section class="article-section">
            <h2>Message Passing en Sistemas Distribuidos</h2>
            <p>
                El paso de mensajes es un patr√≥n fundamental para construir sistemas distribuidos escalables.
                En lugar de comunicaci√≥n directa mediante llamadas de m√©todo, los componentes se comunican
                enviando mensajes inmutables de forma as√≠ncrona.
            </p>
        </section>

        <section class="article-section">
            <h2>Principios del Message Passing</h2>
            
            <div class="pattern-card">
                <h3>üì® Caracter√≠sticas Clave</h3>
                <ul>
                    <li><strong>As√≠ncrono</strong>: El emisor no espera respuesta inmediata</li>
                    <li><strong>Desacoplamiento</strong>: Emisor y receptor no se conocen directamente</li>
                    <li><strong>Inmutabilidad</strong>: Los mensajes son inmutables</li>
                    <li><strong>Location Transparency</strong>: Funciona igual local o remotamente</li>
                    <li><strong>Fire and Forget</strong>: Patr√≥n de env√≠o sin respuesta</li>
                </ul>
            </div>

            <div class="pattern-card">
                <h3>üéØ Ventajas del Message Passing</h3>
                <ul>
                    <li>Permite escalado horizontal natural</li>
                    <li>Facilita tolerancia a fallos</li>
                    <li>Reduce acoplamiento entre componentes</li>
                    <li>Simplifica testing y reasoning</li>
                    <li>Facilita evoluci√≥n del sistema</li>
                </ul>
            </div>
        </section>

        <section class="article-section">
            <h2>Patrones de Mensajer√≠a</h2>
            
            <div class="code-block">
                <pre><code>// Point-to-Point (1-to-1)
actor ! Message("direct message")

// Publish-Subscribe (1-to-many)
mediator ! Publish("topic", Event("broadcast"))

// Request-Response
actor ? Request("query") // retorna Future[Response]

// Message Routing
router ! Message("routed to one of many")

// Dead Letter
// Mensajes sin destinatario van a dead letter office</code></pre>
            </div>
        </section>

        <section class="article-section">
            <h2>Akka Cluster</h2>
            
            <div class="pattern-card">
                <h3>üåê Clustering para Escalabilidad</h3>
                <p>
                    Akka Cluster permite crear aplicaciones distribuidas donde los actores pueden
                    comunicarse a trav√©s de m√∫ltiples nodos de forma transparente.
                </p>
            </div>

            <div class="code-block">
                <pre><code>// Configuraci√≥n de cluster
akka {
  actor {
    provider = "cluster"
  }
  
  remote {
    artery {
      canonical.hostname = "127.0.0.1"
      canonical.port = 2551
    }
  }
  
  cluster {
    seed-nodes = [
      "akka://ClusterSystem@@127.0.0.1:2551",
      "akka://ClusterSystem@@127.0.0.1:2552"
    ]
    
    roles = ["frontend", "backend"]
  }
}

// Usar cluster aware routers
val router = system.actorOf(
  ClusterRouterPool(
    RoundRobinPool(10),
    ClusterRouterPoolSettings(
      totalInstances = 100,
      maxInstancesPerNode = 10,
      allowLocalRoutees = true,
      useRole = Some("backend")
    )
  ).props(Props[WorkerActor]),
  name = "workerRouter"
)</code></pre>
            </div>
        </section>

        <section class="article-section">
            <h2>Distributed Pub-Sub</h2>
            
            <div class="code-block">
                <pre><code>import akka.cluster.pubsub._
import akka.cluster.pubsub.DistributedPubSubMediator._

class PublisherActor extends Actor {
  val mediator = DistributedPubSub(context.system).mediator
  
  def receive = {
    case msg: String =>
      // Publicar a todos los suscriptores del topic
      mediator ! Publish("content", msg)
  }
}

class SubscriberActor extends Actor {
  val mediator = DistributedPubSub(context.system).mediator
  
  override def preStart(): Unit = {
    // Suscribirse al topic
    mediator ! Subscribe("content", self)
  }
  
  def receive = {
    case msg: String =>
      println(s"Received: $msg")
  }
}</code></pre>
            </div>

            <div class="pattern-card">
                <h3>üì° Use Cases de Pub-Sub</h3>
                <ul>
                    <li>Broadcasting de eventos a m√∫ltiples servicios</li>
                    <li>Notificaciones en tiempo real</li>
                    <li>Event sourcing distribuido</li>
                    <li>Cache invalidation</li>
                    <li>Sincronizaci√≥n de estado</li>
                </ul>
            </div>
        </section>

        <section class="article-section">
            <h2>Sharding para Escalabilidad Masiva</h2>
            
            <div class="pattern-card">
                <h3>üîÄ Cluster Sharding</h3>
                <p>
                    Cluster Sharding distribuye autom√°ticamente actores a trav√©s del cluster y
                    gestiona su localizaci√≥n y ciclo de vida.
                </p>
            </div>

            <div class="code-block">
                <pre><code>import akka.cluster.sharding._

// Definir c√≥mo extraer entity ID y shard ID
val extractEntityId: ShardRegion.ExtractEntityId = {
  case msg @@ Command(userId, _) => (userId.toString, msg)
}

val extractShardId: ShardRegion.ExtractShardId = {
  case Command(userId, _) => (userId.hashCode % 100).toString
}

// Iniciar shard region
val userRegion: ActorRef = ClusterSharding(system).start(
  typeName = "User",
  entityProps = Props[UserActor],
  settings = ClusterShardingSettings(system),
  extractEntityId = extractEntityId,
  extractShardId = extractShardId
)

// Enviar mensaje (se rutea autom√°ticamente al nodo correcto)
userRegion ! Command(UserId(123), "update profile")</code></pre>
            </div>

            <div class="pattern-card">
                <h3>üíé Beneficios de Sharding</h3>
                <ul>
                    <li>Distribuci√≥n autom√°tica de carga</li>
                    <li>Rebalanceo din√°mico cuando nodos se unen/salen</li>
                    <li>Location transparency completa</li>
                    <li>Escalado a millones de entidades</li>
                    <li>Persistencia opcional con Event Sourcing</li>
                </ul>
            </div>
        </section>

        <section class="article-section">
            <h2>Message Guarantees</h2>
            
            <div class="pattern-card">
                <h3>üì¨ Sem√°nticas de Entrega</h3>
                <ul>
                    <li><strong>At-Most-Once</strong>: R√°pido, puede perder mensajes (default local)</li>
                    <li><strong>At-Least-Once</strong>: Con reintentos, puede duplicar</li>
                    <li><strong>Exactly-Once</strong>: Requiere idempotencia o deduplicaci√≥n</li>
                </ul>
            </div>

            <div class="code-block">
                <pre><code>// At-least-once delivery con Akka Persistence
class ReliableDeliveryActor extends PersistentActor 
  with AtLeastOnceDelivery {
  
  override def persistenceId = "delivery-actor-1"
  
  def receiveCommand = {
    case msg: BusinessMessage =>
      persist(MessageSent(msg)) { evt =>
        updateState(evt)
        deliver(destinationPath)(deliveryId => 
          DeliveryEnvelope(deliveryId, msg)
        )
      }
    
    case Confirm(deliveryId) =>
      persist(MessageConfirmed(deliveryId)) { evt =>
        confirmDelivery(deliveryId)
      }
  }
  
  def receiveRecover = {
    case evt: MessageSent => updateState(evt)
    case evt: MessageConfirmed => 
      confirmDelivery(evt.deliveryId)
  }
}</code></pre>
            </div>
        </section>

        <section class="article-section">
            <h2>Integraci√≥n con Message Brokers</h2>
            
            <div class="code-block">
                <pre><code>// Kafka Integration
import akka.kafka._
import akka.kafka.scaladsl._

val kafkaProducer = Producer.plainSink(producerSettings)

Source(messages)
  .map(msg => ProducerRecord("topic", msg.key, msg.value))
  .runWith(kafkaProducer)

// RabbitMQ Integration
import com.newmotion.akka.rabbitmq._

val factory = new ConnectionFactory()
val connection = system.actorOf(
  ConnectionActor.props(factory)
)

val exchange = "myExchange"
connection ! CreateChannel(
  ChannelActor.props(channel => {
    channel.exchangeDeclare(exchange, "topic")
  })
)</code></pre>
            </div>
        </section>

        <section class="article-section">
            <h2>Caso de Estudio: Sistema de E-Commerce</h2>
            
            <div class="pattern-card">
                <h3>üõí Arquitectura</h3>
                <p>Sistema distribuido con message passing para:</p>
                <ul>
                    <li><strong>Order Service</strong>: Gestiona pedidos (sharded por order ID)</li>
                    <li><strong>Inventory Service</strong>: Control de stock (pub-sub para updates)</li>
                    <li><strong>Payment Service</strong>: Procesamiento de pagos (request-reply)</li>
                    <li><strong>Notification Service</strong>: Env√≠o de emails/SMS (pub-sub)</li>
                </ul>
            </div>

            <div class="code-block">
                <pre><code>// Flujo de orden
class OrderActor extends PersistentActor {
  def receiveCommand = {
    case PlaceOrder(items, user) =>
      // 1. Reservar inventario (request-response)
      inventory ? ReserveItems(items) map {
        case Reserved =>
          // 2. Procesar pago (request-response)
          payment ? ProcessPayment(user, total)
        case OutOfStock(items) =>
          sender() ! OrderFailed("Items out of stock")
      } flatMap {
        case PaymentSuccess(transactionId) =>
          // 3. Confirmar orden
          persist(OrderPlaced(orderId, items, transactionId)) { evt =>
            updateState(evt)
            // 4. Publicar evento
            pubsub ! Publish("orders", OrderCreated(orderId))
            sender() ! OrderConfirmed(orderId)
          }
        case PaymentFailed(reason) =>
          // Liberar inventario
          inventory ! ReleaseItems(items)
          sender() ! OrderFailed(reason)
      }
  }
}</code></pre>
            </div>
        </section>

        <section class="article-section">
            <h2>M√©tricas y Resultados</h2>
            <div class="benefits-grid">
                <div class="benefit-box">
                    <h4>üìä 10x Throughput</h4>
                    <p>De 1,000 a 10,000 ordenes/seg con mismo hardware</p>
                </div>
                <div class="benefit-box">
                    <h4>‚ö° Latencia p99: 50ms</h4>
                    <p>Respuesta r√°pida incluso bajo carga alta</p>
                </div>
                <div class="benefit-box">
                    <h4>üåç Multi-Region</h4>
                    <p>Despliegue en 3 regiones sin cambios de c√≥digo</p>
                </div>
                <div class="benefit-box">
                    <h4>üí∞ 70% Cost Saving</h4>
                    <p>Reducci√≥n de costos de infraestructura</p>
                </div>
            </div>
        </section>

        <section class="article-section">
            <h2>Recursos Adicionales</h2>
            <ul class="resource-list">
                <li><a href="https://www.reactivedesignpatterns.com/" target="_blank">Reactive Design Patterns - Messaging Patterns</a></li>
                <li><a href="https://doc.akka.io/docs/akka/current/typed/cluster.html" target="_blank">Akka Cluster Documentation</a></li>
                <li><a href="https://www.enterpriseintegrationpatterns.com/" target="_blank">Enterprise Integration Patterns</a></li>
            </ul>
        </section>
    </div>
}
