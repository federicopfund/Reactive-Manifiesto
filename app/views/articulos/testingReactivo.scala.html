@()(implicit request: RequestHeader, messages: Messages)

@articulos.articleLayout("Testing de Sistemas Reactivos", "Recurso", "10 Nov 2025", Seq("Testing", "Akka TestKit", "QA")) {
    <div class="article-body">
        <section class="article-section">
            <h2>Desaf√≠os del Testing Reactivo</h2>
            <p>
                Los sistemas reactivos presentan desaf√≠os √∫nicos para testing debido a su naturaleza
                as√≠ncrona, concurrente y distribuida. Sin embargo, existen herramientas y patrones
                espec√≠ficos que facilitan escribir tests confiables y mantenibles.
            </p>
        </section>

        <section class="article-section">
            <h2>Akka TestKit</h2>
            
            <div class="pattern-card">
                <h3>üß™ Herramienta de Testing para Actores</h3>
                <p>
                    Akka TestKit proporciona utilidades para probar actores de forma s√≠ncrona y
                    determin√≠stica, a pesar de su naturaleza as√≠ncrona.
                </p>
            </div>

            <div class="code-block">
                <pre><code>import akka.actor.ActorSystem
import akka.testkit.{TestKit, TestProbe, ImplicitSender}
import org.scalatest.{BeforeAndAfterAll, WordSpecLike}
import scala.concurrent.duration._

class GreeterActorSpec extends TestKit(ActorSystem("TestSystem"))
  with ImplicitSender
  with WordSpecLike
  with BeforeAndAfterAll {

  override def afterAll(): Unit = {
    TestKit.shutdownActorSystem(system)
  }

  "A Greeter actor" should {
    "respond with greeting" in {
      val greeter = system.actorOf(Props[GreeterActor])
      
      greeter ! Greeting("Hello")
      greeter ! GetGreeting
      
      expectMsg(500.millis, "Hello")
    }

    "handle multiple greetings" in {
      val greeter = system.actorOf(Props[GreeterActor])
      
      greeter ! Greeting("Hi")
      greeter ! Greeting("Hey")
      greeter ! GetGreeting
      
      expectMsg("Hey") // √∫ltimo mensaje
    }
  }
}</code></pre>
            </div>
        </section>

        <section class="article-section">
            <h2>TestProbe: Actores de Prueba</h2>
            
            <div class="code-block">
                <pre><code>class SupervisorActorSpec extends TestKit(ActorSystem("TestSystem"))
  with WordSpecLike {

  "A Supervisor actor" should {
    "forward messages to worker" in {
      val workerProbe = TestProbe()
      val supervisor = system.actorOf(
        Props(new SupervisorActor(workerProbe.ref))
      )
      
      supervisor ! WorkItem("task")
      
      workerProbe.expectMsg(WorkItem("task"))
    }

    "restart worker on failure" in {
      val workerProbe = TestProbe()
      val supervisor = system.actorOf(
        Props(new SupervisorActor(workerProbe.ref))
      )
      
      watch(workerProbe.ref)
      workerProbe.ref ! PoisonPill
      
      expectTerminated(workerProbe.ref)
      // Verificar que se crea nuevo worker
    }
  }
}</code></pre>
            </div>

            <div class="pattern-card">
                <h3>üîç M√©todos √ötiles de TestProbe</h3>
                <ul>
                    <li><code>expectMsg</code>: Espera mensaje espec√≠fico</li>
                    <li><code>expectMsgType[T]</code>: Espera mensaje de tipo T</li>
                    <li><code>expectNoMessage</code>: Verifica que no lleguen mensajes</li>
                    <li><code>expectMsgAnyOf</code>: Espera cualquiera de varios mensajes</li>
                    <li><code>fishForMessage</code>: Busca mensaje que cumple condici√≥n</li>
                    <li><code>receiveN</code>: Recibe N mensajes</li>
                </ul>
            </div>
        </section>

        <section class="article-section">
            <h2>Testing As√≠ncrono</h2>
            
            <div class="code-block">
                <pre><code>import org.scalatest.concurrent.{ScalaFutures, Eventually}
import org.scalatest.time.{Seconds, Span}

class AsyncServiceSpec extends WordSpec 
  with ScalaFutures 
  with Eventually {

  implicit val patience = PatienceConfig(
    timeout = Span(5, Seconds),
    interval = Span(500, Millis)
  )

  "AsyncService" should {
    "return data eventually" in {
      val service = new AsyncService()
      
      val futureResult = service.fetchData()
      
      whenReady(futureResult) { result =>
        result should not be empty
      }
    }

    "handle concurrent operations" in {
      val service = new AsyncService()
      
      val futures = (1 to 100).map { i =>
        service.processItem(i)
      }
      
      val combined = Future.sequence(futures)
      
      whenReady(combined) { results =>
        results should have size 100
        results should contain only (Success)
      }
    }
  }
}</code></pre>
            </div>
        </section>

        <section class="article-section">
            <h2>Testing de Streams</h2>
            
            <div class="pattern-card">
                <h3>üåä Akka Streams TestKit</h3>
                <p>
                    Herramientas espec√≠ficas para probar flujos de Akka Streams con control
                    preciso sobre demanda y producci√≥n de elementos.
                </p>
            </div>

            <div class="code-block">
                <pre><code>import akka.stream.testkit.scaladsl.{TestSink, TestSource}
import akka.stream.testkit.{TestPublisher, TestSubscriber}

class StreamProcessorSpec extends WordSpec {
  implicit val system = ActorSystem()
  implicit val materializer = ActorMaterializer()

  "Stream processor" should {
    "transform elements correctly" in {
      val (pub, sub) = TestSource.probe[Int]
        .via(processingFlow)
        .toMat(TestSink.probe[String])(Keep.both)
        .run()
      
      sub.request(3)
      pub.sendNext(1)
      pub.sendNext(2)
      pub.sendNext(3)
      
      sub.expectNext("1", "2", "3")
      
      pub.sendComplete()
      sub.expectComplete()
    }

    "handle backpressure" in {
      val (pub, sub) = TestSource.probe[Int]
        .via(slowFlow)
        .toMat(TestSink.probe[Int])(Keep.both)
        .run()
      
      // No request, so should not receive
      pub.sendNext(1)
      sub.expectNoMessage(100.millis)
      
      // Now request
      sub.request(1)
      sub.expectNext(1)
    }

    "propagate errors" in {
      val (pub, sub) = TestSource.probe[Int]
        .via(faultyFlow)
        .toMat(TestSink.probe[Int])(Keep.both)
        .run()
      
      sub.request(10)
      pub.sendNext(1)
      pub.sendError(new RuntimeException("boom"))
      
      sub.expectError() should be (a[RuntimeException])
    }
  }
}</code></pre>
            </div>
        </section>

        <section class="article-section">
            <h2>Property-Based Testing</h2>
            
            <div class="pattern-card">
                <h3>üé≤ ScalaCheck</h3>
                <p>
                    Property-based testing genera casos de prueba autom√°ticamente, ideal para
                    sistemas con comportamiento complejo o muchos estados posibles.
                </p>
            </div>

            <div class="code-block">
                <pre><code>import org.scalacheck.Prop.forAll
import org.scalacheck.Properties

object ProcessorSpecification extends Properties("Processor") {

  property("idempotent processing") = forAll { (data: String) =>
    val processor = new DataProcessor()
    val result1 = processor.process(data)
    val result2 = processor.process(data)
    
    result1 == result2
  }

  property("order preservation") = forAll { (items: List[Int]) =>
    val processor = new OrderProcessor()
    val processed = processor.processInOrder(items)
    
    processed.zipWithIndex.forall { case (item, idx) =>
      idx == 0 || processed(idx - 1) <= item
    }
  }

  property("no data loss") = forAll { (input: List[String]) =>
    val processor = new StreamProcessor()
    val output = processor.transform(input)
    
    output.size == input.size
  }
}</code></pre>
            </div>
        </section>

        <section class="article-section">
            <h2>Testing de Cluster</h2>
            
            <div class="code-block">
                <pre><code>import akka.cluster.Cluster
import akka.cluster.ClusterEvent._
import akka.remote.testkit.MultiNodeSpec

class ClusterSpec extends MultiNodeSpec(ClusterConfig) 
  with STMultiNodeSpec {

  "A cluster" must {
    "form correctly" in {
      awaitClusterUp(first, second, third)
      
      enterBarrier("cluster-formed")
    }

    "handle node leaving" in within(15.seconds) {
      runOn(first) {
        Cluster(system).leave(second)
      }
      
      runOn(first, third) {
        awaitAssert {
          Cluster(system).state.members.size should be(2)
        }
      }
      
      enterBarrier("node-removed")
    }

    "distribute sharded entities" in {
      val region = ClusterSharding(system).shardRegion("User")
      
      runOn(first) {
        (1 to 100).foreach { id =>
          region ! UserCommand(id, "test")
        }
      }
      
      enterBarrier("commands-sent")
      
      // Verificar distribuci√≥n
      val localCount = getLocalEntityCount()
      localCount should be > 0
      localCount should be < 100
    }
  }
}</code></pre>
            </div>
        </section>

        <section class="article-section">
            <h2>Mocking y Stubbing</h2>
            
            <div class="code-block">
                <pre><code>import org.scalamock.scalatest.MockFactory

class ServiceSpec extends WordSpec with MockFactory {

  "OrderService" should {
    "call external services correctly" in {
      // Mock dependencies
      val mockInventory = mock[InventoryService]
      val mockPayment = mock[PaymentService]
      
      // Setup expectations
      (mockInventory.checkStock _)
        .expects("item-123")
        .returning(Future.successful(InStock))
      
      (mockPayment.charge _)
        .expects(*, 100.0)
        .returning(Future.successful(PaymentSuccess))
      
      // Test service
      val service = new OrderService(mockInventory, mockPayment)
      val result = service.placeOrder(Order("item-123", 1))
      
      whenReady(result) { order =>
        order.status should be(Confirmed)
      }
    }
  }
}</code></pre>
            </div>
        </section>

        <section class="article-section">
            <h2>Integration Testing</h2>
            
            <div class="pattern-card">
                <h3>üîó Testing de Integraci√≥n</h3>
                <p>Probar el sistema completo con dependencias reales:</p>
                <ul>
                    <li><strong>Embedded Kafka</strong>: Para testing de consumers/producers</li>
                    <li><strong>TestContainers</strong>: Bases de datos y servicios en Docker</li>
                    <li><strong>WireMock</strong>: APIs externas mockeadas</li>
                </ul>
            </div>

            <div class="code-block">
                <pre><code>import com.dimafeng.testcontainers._
import org.testcontainers.containers.PostgreSQLContainer

class IntegrationSpec extends WordSpec with ForAllTestContainer {

  override val container = PostgreSQLContainer()

  "Full system" should {
    "process end-to-end flow" in {
      // Setup con base de datos real
      val dbConfig = container.jdbcUrl
      val system = createSystem(dbConfig)
      
      // Ejecutar flujo completo
      val orderId = placeOrder(...)
      val order = waitForOrder(orderId)
      val payment = waitForPayment(orderId)
      
      order.status should be(Completed)
      payment.status should be(Successful)
    }
  }
}</code></pre>
            </div>
        </section>

        <section class="article-section">
            <h2>Testing Patterns</h2>
            
            <div class="pattern-card">
                <h3>‚úÖ Best Practices</h3>
                <ul>
                    <li><strong>Test Isolation</strong>: Cada test debe ser independiente</li>
                    <li><strong>Deterministic Tests</strong>: Evitar timing dependencies</li>
                    <li><strong>Fast Feedback</strong>: Tests unitarios r√°pidos</li>
                    <li><strong>Pyramid Structure</strong>: Muchos unit, menos integration</li>
                    <li><strong>Meaningful Assertions</strong>: Verificar comportamiento, no implementaci√≥n</li>
                </ul>
            </div>
        </section>

        <section class="article-section">
            <h2>Herramientas Recomendadas</h2>
            <div class="benefits-grid">
                <div class="benefit-box">
                    <h4>üß™ ScalaTest</h4>
                    <p>Framework de testing vers√°til y expresivo</p>
                </div>
                <div class="benefit-box">
                    <h4>üîç Akka TestKit</h4>
                    <p>Testing espec√≠fico para actores</p>
                </div>
                <div class="benefit-box">
                    <h4>üé≤ ScalaCheck</h4>
                    <p>Property-based testing autom√°tico</p>
                </div>
                <div class="benefit-box">
                    <h4>üê≥ TestContainers</h4>
                    <p>Dependencias en contenedores Docker</p>
                </div>
            </div>
        </section>

        <section class="article-section">
            <h2>Recursos Adicionales</h2>
            <ul class="resource-list">
                <li><a href="https://doc.akka.io/docs/akka/current/testing.html" target="_blank">Akka Testing Documentation</a></li>
                <li><a href="https://www.scalatest.org/" target="_blank">ScalaTest Official Site</a></li>
                <li><a href="https://www.scalacheck.org/" target="_blank">ScalaCheck Documentation</a></li>
                <li><a href="https://www.reactivedesignpatterns.com/" target="_blank">Reactive Design Patterns - Testing Patterns</a></li>
            </ul>
        </section>
    </div>
}
