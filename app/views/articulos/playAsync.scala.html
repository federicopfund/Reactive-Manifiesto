@()(implicit request: RequestHeader, messages: Messages)

@articulos.articleLayout("Play Framework y ProgramaciÃ³n AsÃ­ncrona", "Tutorial", "25 Nov 2025", Seq("Play Framework", "Async", "Web")) {
    <div class="article-body">
        <section class="article-section">
            <h2>Play Framework: AsÃ­ncrono por DiseÃ±o</h2>
            <p>
                Play Framework estÃ¡ construido desde cero para ser completamente asÃ­ncrono y no bloqueante.
                Aprovecha Scala Futures, Akka y el modelo reactivo para proporcionar alta escalabilidad
                y rendimiento en aplicaciones web.
            </p>
        </section>

        <section class="article-section">
            <h2>Non-Blocking I/O</h2>
            
            <div class="pattern-card">
                <h3>ðŸš€ Arquitectura AsÃ­ncrona</h3>
                <p>
                    A diferencia de frameworks tradicionales que usan un thread por request, Play usa:
                </p>
                <ul>
                    <li><strong>Event Loop</strong>: Procesa mÃºltiples requests con pocos threads</li>
                    <li><strong>Non-blocking I/O</strong>: No bloquea threads esperando operaciones I/O</li>
                    <li><strong>Future-based</strong>: Todas las operaciones asÃ­ncronas retornan Futures</li>
                    <li><strong>Akka HTTP</strong>: Servidor HTTP reactivo y escalable</li>
                </ul>
            </div>
        </section>

        <section class="article-section">
            <h2>Actions AsÃ­ncronas</h2>
            
            <div class="code-block">
                <pre><code>import play.api.mvc._
import scala.concurrent.{Future, ExecutionContext}
import javax.inject.Inject

class AsyncController @@Inject()(
  cc: ControllerComponents
)(implicit ec: ExecutionContext) extends AbstractController(cc) {

  // Action sÃ­ncrona tradicional (bloqueante)
  def syncAction = Action { implicit request =>
    val result = blockingDatabaseCall()
    Ok(result)
  }

  // Action asÃ­ncrona (recomendada)
  def asyncAction = Action.async { implicit request =>
    asyncDatabaseCall().map { result =>
      Ok(result)
    }
  }

  // MÃºltiples operaciones asÃ­ncronas en paralelo
  def parallelAction = Action.async { implicit request =>
    val future1 = service1.getData()
    val future2 = service2.getData()
    val future3 = service3.getData()
    
    for {
      data1 <- future1
      data2 <- future2
      data3 <- future3
    } yield {
      Ok(combineResults(data1, data2, data3))
    }
  }
}</code></pre>
            </div>

            <div class="pattern-card">
                <h3>âš¡ Ventajas de Actions AsÃ­ncronas</h3>
                <ul>
                    <li>Mejor utilizaciÃ³n de recursos del servidor</li>
                    <li>Mayor throughput y menor latencia</li>
                    <li>Escalabilidad horizontal mÃ¡s efectiva</li>
                    <li>Mejor manejo de operaciones I/O</li>
                </ul>
            </div>
        </section>

        <section class="article-section">
            <h2>Manejo de Timeouts</h2>
            
            <div class="code-block">
                <pre><code>import play.api.libs.concurrent.Futures._
import scala.concurrent.duration._

class TimeoutController @@Inject()(
  cc: ControllerComponents,
  futures: Futures
)(implicit ec: ExecutionContext) extends AbstractController(cc) {

  def actionWithTimeout = Action.async { implicit request =>
    val operation = slowService.getData()
    
    operation.withTimeout(5.seconds).map { result =>
      Ok(result)
    }.recover {
      case _: TimeoutException =>
        RequestTimeout("Operation timed out")
    }
  }

  // Timeout con valor por defecto
  def actionWithFallback = Action.async { implicit request =>
    val operation = externalService.call()
    
    operation.withTimeout(3.seconds).recover {
      case _: TimeoutException =>
        defaultValue
    }.map { result =>
      Ok(result)
    }
  }
}</code></pre>
            </div>
        </section>

        <section class="article-section">
            <h2>Streaming de Respuestas</h2>
            
            <div class="pattern-card">
                <h3>ðŸ“¡ Respuestas Chunked</h3>
                <p>
                    Play permite streaming de respuestas grandes sin cargar todo en memoria:
                </p>
            </div>

            <div class="code-block">
                <pre><code>import akka.stream.scaladsl._

class StreamingController @@Inject()(
  cc: ControllerComponents
)(implicit ec: ExecutionContext) extends AbstractController(cc) {

  // Streaming de archivo grande
  def downloadLargeFile = Action {
    val file = new java.io.File("/path/to/large/file.dat")
    val source: Source[ByteString, _] = 
      FileIO.fromPath(file.toPath)
    
    Ok.chunked(source)
  }

  // Server-Sent Events (SSE)
  def eventStream = Action {
    val source = Source
      .tick(1.second, 1.second, "tick")
      .map { msg =>
        ServerSentEvent(msg)
      }
    
    Ok.chunked(source via EventSource.flow)
      .as(ContentTypes.EVENT_STREAM)
  }

  // Streaming de datos de base de datos
  def streamRecords = Action {
    val source = Source
      .fromPublisher(databasePublisher)
      .map(record => Json.toJson(record))
      .intersperse("[", ",", "]")
    
    Ok.chunked(source)
      .as(JSON)
  }
}</code></pre>
            </div>
        </section>

        <section class="article-section">
            <h2>WebSockets</h2>
            
            <div class="code-block">
                <pre><code>import play.api.libs.streams._
import akka.stream.Materializer

class WebSocketController @@Inject()(
  cc: ControllerComponents
)(implicit mat: Materializer) extends AbstractController(cc) {

  def socket = WebSocket.accept[String, String] { request =>
    ActorFlow.actorRef { out =>
      ChatActor.props(out)
    }
  }

  // WebSocket con procesamiento de stream
  def echoSocket = WebSocket.accept[String, String] { request =>
    Flow[String].map { msg =>
      s"Echo: $msg"
    }
  }

  // WebSocket con backpressure
  def throttledSocket = WebSocket.accept[String, String] { request =>
    Flow[String]
      .throttle(10, 1.second)
      .map(processMessage)
  }
}</code></pre>
            </div>

            <div class="pattern-card">
                <h3>ðŸ”Œ Casos de Uso de WebSockets</h3>
                <ul>
                    <li>Chat en tiempo real</li>
                    <li>Notificaciones push</li>
                    <li>Dashboards en vivo</li>
                    <li>ColaboraciÃ³n en tiempo real</li>
                    <li>Gaming multiplayer</li>
                </ul>
            </div>
        </section>

        <section class="article-section">
            <h2>ComposiciÃ³n de Futures</h2>
            
            <div class="code-block">
                <pre><code>// Sequential composition
for {
  user <- userService.findById(id)
  orders <- orderService.findByUser(user.id)
  details <- orders.map(o => orderService.getDetails(o.id))
} yield (user, details)

// Parallel composition
val userFuture = userService.findById(id)
val ordersFuture = orderService.findByUser(id)
val productsFuture = productService.findAll()

Future.sequence(Seq(userFuture, ordersFuture, productsFuture))

// Error handling
userService.findById(id).map { user =>
  Ok(Json.toJson(user))
}.recover {
  case _: NotFoundException => NotFound
  case _: UnauthorizedException => Unauthorized
  case ex: Exception => 
    logger.error("Error finding user", ex)
    InternalServerError
}

// Fallback chain
primaryService.getData()
  .recoverWith { case _ => secondaryService.getData() }
  .recoverWith { case _ => cacheService.getData() }
  .map(data => Ok(data))
  .recover { case _ => ServiceUnavailable }</code></pre>
            </div>
        </section>

        <section class="article-section">
            <h2>IntegraciÃ³n con Reactive Mongo</h2>
            
            <div class="code-block">
                <pre><code>import reactivemongo.api._
import reactivemongo.api.bson._
import play.modules.reactivemongo._

class UserRepository @@Inject()(
  val reactiveMongoApi: ReactiveMongoApi
)(implicit ec: ExecutionContext) {

  def collection = reactiveMongoApi.database
    .map(_.collection[BSONCollection]("users"))

  // OperaciÃ³n asÃ­ncrona
  def findById(id: String): Future[Option[User]] = {
    collection.flatMap(
      _.find(BSONDocument("_id" -> id))
       .one[User]
    )
  }

  // Streaming de resultados
  def streamAll(): Source[User, Future[State]] = {
    Source.fromFuture(collection).flatMapConcat { coll =>
      coll.find(BSONDocument.empty)
          .cursor[User]()
          .documentSource()
    }
  }
}</code></pre>
            </div>
        </section>

        <section class="article-section">
            <h2>Best Practices</h2>
            <div class="pattern-card">
                <h3>âœ… Recomendaciones</h3>
                <ul>
                    <li>Usa <code>Action.async</code> para todas las operaciones I/O</li>
                    <li>Evita bloquear threads con operaciones sÃ­ncronas</li>
                    <li>Usa execution contexts apropiados para diferentes tipos de trabajo</li>
                    <li>Implementa timeouts en todas las operaciones externas</li>
                    <li>Maneja errores apropiadamente con <code>recover</code> y <code>recoverWith</code></li>
                    <li>Usa streaming para respuestas grandes</li>
                    <li>Aprovecha composiciÃ³n de Futures para paralelizar operaciones</li>
                </ul>
            </div>
        </section>

        <section class="article-section">
            <h2>Beneficios</h2>
            <div class="benefits-grid">
                <div class="benefit-box">
                    <h4>ðŸ“ˆ Escalabilidad</h4>
                    <p>Maneja miles de conexiones concurrentes con pocos recursos</p>
                </div>
                <div class="benefit-box">
                    <h4>âš¡ Performance</h4>
                    <p>Menor latencia y mayor throughput que frameworks bloqueantes</p>
                </div>
                <div class="benefit-box">
                    <h4>ðŸ’ª Resiliencia</h4>
                    <p>Mejor manejo de fallos y timeouts</p>
                </div>
                <div class="benefit-box">
                    <h4>ðŸ”„ Reactive</h4>
                    <p>Cumple con los principios del Manifiesto Reactivo</p>
                </div>
            </div>
        </section>

        <section class="article-section">
            <h2>Recursos Adicionales</h2>
            <ul class="resource-list">
                <li><a href="https://www.playframework.com/documentation/latest/ScalaAsync" target="_blank">Play Framework - Asynchronous Programming</a></li>
                <li><a href="https://www.reactivedesignpatterns.com/" target="_blank">Reactive Design Patterns</a></li>
                <li><a href="https://doc.akka.io/docs/akka-http/current/" target="_blank">Akka HTTP Documentation</a></li>
            </ul>
        </section>
    </div>
}
