@()(implicit request: RequestHeader, messages: Messages)

@articulos.articleLayout("Streams Reactivos con Akka Streams", "Gu√≠a", "1 Dic 2025", Seq("Akka Streams", "Reactive Streams", "Backpressure")) {
    <div class="article-body">
        <section class="article-section">
            <h2>Introducci√≥n a Akka Streams</h2>
            <p>
                Akka Streams es una implementaci√≥n de Reactive Streams que proporciona una API de alto nivel
                para procesar flujos de datos con backpressure autom√°tico. Permite construir pipelines de
                procesamiento complejos de manera declarativa y type-safe.
            </p>
        </section>

        <section class="article-section">
            <h2>Reactive Streams Specification</h2>
            
            <div class="pattern-card">
                <h3>üìä Los Cuatro Componentes</h3>
                <p>La especificaci√≥n Reactive Streams define cuatro interfaces clave:</p>
                <ul>
                    <li><strong>Publisher</strong>: Produce elementos y los env√≠a a Subscribers</li>
                    <li><strong>Subscriber</strong>: Consume elementos de un Publisher</li>
                    <li><strong>Subscription</strong>: Representa la conexi√≥n entre Publisher y Subscriber</li>
                    <li><strong>Processor</strong>: Act√∫a como Publisher y Subscriber simult√°neamente</li>
                </ul>
            </div>

            <div class="pattern-card">
                <h3>üîÑ Backpressure</h3>
                <p>
                    Backpressure es el mecanismo que permite a los consumidores controlar la velocidad
                    de producci√≥n de datos. Previene:
                </p>
                <ul>
                    <li>Desbordamiento de buffers</li>
                    <li>OutOfMemoryErrors</li>
                    <li>Degradaci√≥n del rendimiento</li>
                    <li>P√©rdida de datos</li>
                </ul>
            </div>
        </section>

        <section class="article-section">
            <h2>Componentes de Akka Streams</h2>
            
            <div class="code-block">
                <pre><code>import akka.stream._
import akka.stream.scaladsl._

implicit val system = ActorSystem("StreamsSystem")
implicit val materializer = ActorMaterializer()

// Source: Origen de datos
val source: Source[Int, NotUsed] = Source(1 to 100)

// Flow: Transformaci√≥n
val flow: Flow[Int, String, NotUsed] = 
  Flow[Int].map(i => s"Number: $i")

// Sink: Destino final
val sink: Sink[String, Future[Done]] = 
  Sink.foreach[String](println)

// Conectar y materializar
val graph = source.via(flow).to(sink)
graph.run()</code></pre>
            </div>

            <div class="pattern-card">
                <h3>üîß Operadores Principales</h3>
                <ul>
                    <li><strong>map</strong>: Transforma cada elemento</li>
                    <li><strong>filter</strong>: Filtra elementos basado en predicado</li>
                    <li><strong>fold/reduce</strong>: Agrega elementos</li>
                    <li><strong>flatMapConcat</strong>: Mapea y concatena streams</li>
                    <li><strong>groupBy</strong>: Divide stream en substreams</li>
                    <li><strong>merge</strong>: Combina m√∫ltiples streams</li>
                </ul>
            </div>
        </section>

        <section class="article-section">
            <h2>Manejo de Backpressure</h2>
            
            <div class="code-block">
                <pre><code>// Buffer strategies
val bufferedFlow = Flow[Int]
  .buffer(100, OverflowStrategy.backpressure)

// Drop strategies
val droppingFlow = Flow[Int]
  .buffer(100, OverflowStrategy.dropHead) // drop oldest
  // .dropTail  // drop newest
  // .dropBuffer // drop all buffered
  // .dropNew   // drop incoming

// Throttling (rate limiting)
val throttledSource = Source(1 to 1000)
  .throttle(
    elements = 10,
    per = 1.second,
    maximumBurst = 100,
    mode = ThrottleMode.Shaping
  )</code></pre>
            </div>

            <div class="pattern-card">
                <h3>‚öñÔ∏è Estrategias de Buffer</h3>
                <ul>
                    <li><strong>Backpressure</strong>: Ralentiza el productor (predeterminado)</li>
                    <li><strong>DropHead</strong>: Descarta elementos m√°s antiguos</li>
                    <li><strong>DropTail</strong>: Descarta elementos m√°s recientes</li>
                    <li><strong>DropBuffer</strong>: Descarta todo el buffer</li>
                    <li><strong>DropNew</strong>: Rechaza elementos nuevos</li>
                    <li><strong>Fail</strong>: Falla el stream</li>
                </ul>
            </div>
        </section>

        <section class="article-section">
            <h2>Procesamiento As√≠ncrono</h2>
            
            <div class="code-block">
                <pre><code>// mapAsync: Procesa elementos en paralelo
val asyncFlow = Flow[Int]
  .mapAsync(parallelism = 4) { i =>
    Future {
      // Operaci√≥n as√≠ncrona costosa
      expensiveComputation(i)
    }
  }

// mapAsyncUnordered: Sin garant√≠a de orden
val unorderedFlow = Flow[Int]
  .mapAsyncUnordered(parallelism = 10) { i =>
    callExternalService(i)
  }

// Ejemplo completo con error handling
Source(1 to 1000)
  .mapAsync(4) { i =>
    externalApiCall(i).recover {
      case ex: Exception => 
        logger.error(s"Failed for $i", ex)
        None
    }
  }
  .collect { case Some(result) => result }
  .runWith(Sink.seq)</code></pre>
            </div>
        </section>

        <section class="article-section">
            <h2>Graphs y Topolog√≠as Complejas</h2>
            
            <div class="code-block">
                <pre><code>val graph = RunnableGraph.fromGraph(GraphDSL.create() { implicit builder =>
  import GraphDSL.Implicits._

  val source = Source(1 to 100)
  val broadcast = builder.add(Broadcast[Int](2))
  val merge = builder.add(Merge[Int](2))
  
  val evens = Flow[Int].filter(_ % 2 == 0)
  val odds = Flow[Int].filter(_ % 2 != 0)
  
  source ~> broadcast
  
  broadcast.out(0) ~> evens ~> merge
  broadcast.out(1) ~> odds  ~> merge
  
  merge ~> Sink.foreach(println)
  
  ClosedShape
})</code></pre>
            </div>

            <div class="pattern-card">
                <h3>üîÄ Componentes de Graph</h3>
                <ul>
                    <li><strong>Broadcast</strong>: Distribuye a m√∫ltiples salidas</li>
                    <li><strong>Merge</strong>: Combina m√∫ltiples entradas</li>
                    <li><strong>Balance</strong>: Distribuye con balanceo de carga</li>
                    <li><strong>Zip</strong>: Combina elementos por pares</li>
                    <li><strong>Partition</strong>: Rutea basado en predicado</li>
                </ul>
            </div>
        </section>

        <section class="article-section">
            <h2>Integraci√≥n con Kafka</h2>
            
            <div class="code-block">
                <pre><code>import akka.kafka._
import akka.kafka.scaladsl._

// Kafka Source (Consumer)
val kafkaSource = Consumer
  .plainSource(
    ConsumerSettings(system, Deserializers.string, Deserializers.string)
      .withBootstrapServers("localhost:9092")
      .withGroupId("my-group"),
    Subscriptions.topics("my-topic")
  )

// Kafka Sink (Producer)
val kafkaSink = Producer.plainSink(
  ProducerSettings(system, Serializers.string, Serializers.string)
    .withBootstrapServers("localhost:9092")
)

// Pipeline completo
kafkaSource
  .map(record => record.value())
  .via(processingFlow)
  .map(result => ProducerRecord("output-topic", result))
  .runWith(kafkaSink)</code></pre>
            </div>
        </section>

        <section class="article-section">
            <h2>Manejo de Errores</h2>
            
            <div class="pattern-card">
                <h3>üö® Estrategias de Recuperaci√≥n</h3>
                <ul>
                    <li><strong>recover</strong>: Proporciona valor por defecto</li>
                    <li><strong>recoverWithRetries</strong>: Reintenta con l√≠mite</li>
                    <li><strong>restart</strong>: Reinicia el stream autom√°ticamente</li>
                    <li><strong>supervision</strong>: Estrategia personalizada</li>
                </ul>
            </div>

            <div class="code-block">
                <pre><code>// Supervision strategy
val decider: Supervision.Decider = {
  case _: IllegalArgumentException => Supervision.Resume
  case _: RuntimeException => Supervision.Restart
  case _ => Supervision.Stop
}

implicit val system = ActorSystem()
implicit val materializer = ActorMaterializer(
  ActorMaterializerSettings(system)
    .withSupervisionStrategy(decider)
)

// Restart on error
val restartingSource = RestartSource.onFailuresWithBackoff(
  minBackoff = 3.seconds,
  maxBackoff = 30.seconds,
  randomFactor = 0.2
) { () =>
  Source.fromFuture(riskyOperation())
}</code></pre>
            </div>
        </section>

        <section class="article-section">
            <h2>Beneficios de Akka Streams</h2>
            <div class="benefits-grid">
                <div class="benefit-box">
                    <h4>üîÑ Backpressure Autom√°tico</h4>
                    <p>Gesti√≥n autom√°tica del flujo de datos sin desbordamientos</p>
                </div>
                <div class="benefit-box">
                    <h4>üìê Type-Safe</h4>
                    <p>Composici√≥n type-safe verificada en tiempo de compilaci√≥n</p>
                </div>
                <div class="benefit-box">
                    <h4>‚ö° Alto Rendimiento</h4>
                    <p>Procesamiento eficiente con m√≠nima overhead</p>
                </div>
                <div class="benefit-box">
                    <h4>üîå Interoperabilidad</h4>
                    <p>Compatible con especificaci√≥n Reactive Streams</p>
                </div>
            </div>
        </section>

        <section class="article-section">
            <h2>Recursos Adicionales</h2>
            <ul class="resource-list">
                <li><a href="https://www.reactivedesignpatterns.com/" target="_blank">Reactive Design Patterns - Stream Processing</a></li>
                <li><a href="https://doc.akka.io/docs/akka/current/stream/index.html" target="_blank">Akka Streams Documentation</a></li>
                <li><a href="https://www.reactive-streams.org/" target="_blank">Reactive Streams Specification</a></li>
            </ul>
        </section>
    </div>
}
