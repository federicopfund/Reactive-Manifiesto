@()(implicit request: RequestHeader, messages: Messages)

@articulos.articleLayout("Patrones de Resiliencia", "Art√≠culo", "8 Dic 2025", Seq("Patrones", "Resiliencia", "Arquitectura")) {
    <div class="article-body">
        <section class="article-section">
            <h2>Dise√±ando Sistemas Resilientes</h2>
            <p>
                La resiliencia es un pilar fundamental del manifiesto reactivo. Un sistema resiliente
                permanece responsivo ante fallos, se recupera r√°pidamente y minimiza el impacto en
                los usuarios. Exploraremos tres patrones clave de resiliencia.
            </p>
        </section>

        <section class="article-section">
            <h2>Circuit Breaker Pattern</h2>
            
            <div class="pattern-card">
                <h3>‚ö° ¬øQu√© es un Circuit Breaker?</h3>
                <p>
                    El patr√≥n Circuit Breaker previene que una aplicaci√≥n intente ejecutar operaciones
                    que probablemente fallar√°n. Funciona como un interruptor el√©ctrico que se "abre"
                    cuando detecta muchos fallos.
                </p>
                
                <h4>Estados del Circuit Breaker:</h4>
                <ul>
                    <li><strong>Closed</strong>: Operaci√≥n normal, las peticiones pasan</li>
                    <li><strong>Open</strong>: Se detectaron fallos, las peticiones fallan inmediatamente</li>
                    <li><strong>Half-Open</strong>: Prueba si el servicio se recuper√≥</li>
                </ul>
            </div>

            <div class="code-block">
                <pre><code>import akka.pattern.CircuitBreaker
import scala.concurrent.duration._

val breaker = new CircuitBreaker(
  scheduler = system.scheduler,
  maxFailures = 5,
  callTimeout = 10.seconds,
  resetTimeout = 1.minute
)

// Usar el circuit breaker
val future = breaker.withCircuitBreaker {
  externalService.call()
}

breaker.onOpen {
  println("Circuit breaker opened!")
}

breaker.onHalfOpen {
  println("Circuit breaker half-open, testing...")
}

breaker.onClose {
  println("Circuit breaker closed, service recovered")
}</code></pre>
            </div>

            <div class="pattern-card">
                <h3>üìä Beneficios del Circuit Breaker</h3>
                <ul>
                    <li>Previene cascadas de fallos en sistemas distribuidos</li>
                    <li>Mejora el tiempo de respuesta al fallar r√°pido</li>
                    <li>Permite que servicios degradados se recuperen</li>
                    <li>Proporciona fallbacks y respuestas por defecto</li>
                </ul>
            </div>
        </section>

        <section class="article-section">
            <h2>Bulkhead Pattern</h2>
            
            <div class="pattern-card">
                <h3>üö¢ Aislamiento de Recursos</h3>
                <p>
                    El patr√≥n Bulkhead a√≠sla recursos en "compartimentos" separados, similar a los
                    compartimentos estancos de un barco. Si un compartimento falla, los otros
                    contin√∫an funcionando.
                </p>
                
                <h4>Tipos de Bulkheads:</h4>
                <ul>
                    <li><strong>Thread Pool Bulkheads</strong>: Pools de threads separados por servicio</li>
                    <li><strong>Semaphore Bulkheads</strong>: L√≠mites de concurrencia por recurso</li>
                    <li><strong>Actor Bulkheads</strong>: Grupos de actores aislados</li>
                </ul>
            </div>

            <div class="code-block">
                <pre><code>import scala.concurrent.{ExecutionContext, Future}
import java.util.concurrent.Executors

// Crear execution contexts separados (bulkheads)
val databaseEC = ExecutionContext.fromExecutor(
  Executors.newFixedThreadPool(10)
)

val externalApiEC = ExecutionContext.fromExecutor(
  Executors.newFixedThreadPool(5)
)

// Usar bulkheads espec√≠ficos
def queryDatabase(): Future[Result] = Future {
  // operaci√≥n de base de datos
}(databaseEC)

def callExternalApi(): Future[Response] = Future {
  // llamada API externa
}(externalApiEC)</code></pre>
            </div>
        </section>

        <section class="article-section">
            <h2>Timeout Pattern</h2>
            
            <div class="pattern-card">
                <h3>‚è±Ô∏è Gesti√≥n de Tiempos de Espera</h3>
                <p>
                    Los timeouts previenen que operaciones lentas o bloqueadas consuman recursos
                    indefinidamente. Son esenciales para mantener la responsividad del sistema.
                </p>
            </div>

            <div class="code-block">
                <pre><code>import akka.pattern.after
import scala.concurrent.duration._

// Timeout simple
val futureWithTimeout = Future.firstCompletedOf(Seq(
  slowOperation(),
  after(5.seconds, system.scheduler)(
    Future.failed(new TimeoutException("Operation timed out"))
  )
))

// Timeout con fallback
futureWithTimeout.recover {
  case _: TimeoutException => 
    defaultValue // respuesta por defecto
}</code></pre>
            </div>
        </section>

        <section class="article-section">
            <h2>Retry Pattern</h2>
            
            <div class="pattern-card">
                <h3>üîÑ Reintentos Inteligentes</h3>
                <p>
                    El patr√≥n Retry maneja fallos transitorios reintentando operaciones con
                    estrategias de backoff para evitar sobrecargar servicios.
                </p>
                
                <h4>Estrategias de Retry:</h4>
                <ul>
                    <li><strong>Exponential Backoff</strong>: Aumenta el tiempo entre reintentos</li>
                    <li><strong>Jitter</strong>: A√±ade aleatoriedad para evitar tormentas de reintentos</li>
                    <li><strong>Max Attempts</strong>: L√≠mite de intentos antes de fallar</li>
                </ul>
            </div>

            <div class="code-block">
                <pre><code>import scala.concurrent.duration._
import akka.pattern.retry

def retryWithBackoff[T](
  operation: () => Future[T],
  maxRetries: Int = 3,
  delay: FiniteDuration = 1.second
): Future[T] = {
  retry(
    () => operation(),
    attempts = maxRetries,
    delay = delay,
    backoff = 2.0, // exponential backoff
    jitter = 0.2   // 20% jitter
  )(system.dispatcher, system.scheduler)
}</code></pre>
            </div>
        </section>

        <section class="article-section">
            <h2>Combinando Patrones</h2>
            <div class="pattern-card">
                <h3>üîó Estrategia Completa de Resiliencia</h3>
                <p>
                    Los patrones de resiliencia son m√°s efectivos cuando se combinan:
                </p>
                <ul>
                    <li>Circuit Breaker + Retry: Previene reintentos innecesarios</li>
                    <li>Bulkhead + Timeout: A√≠sla y limita recursos bloqueados</li>
                    <li>Circuit Breaker + Fallback: Proporciona respuestas alternativas</li>
                </ul>
            </div>

            <div class="benefits-grid">
                <div class="benefit-box">
                    <h4>üõ°Ô∏è Fault Tolerance</h4>
                    <p>El sistema contin√∫a funcionando ante fallos parciales</p>
                </div>
                <div class="benefit-box">
                    <h4>‚ö° Fast Fail</h4>
                    <p>Respuestas r√°pidas incluso cuando servicios fallan</p>
                </div>
                <div class="benefit-box">
                    <h4>üîç Observabilidad</h4>
                    <p>M√©tricas y monitoreo de salud del sistema</p>
                </div>
                <div class="benefit-box">
                    <h4>üåä Cascading Prevention</h4>
                    <p>Evita que fallos se propaguen a todo el sistema</p>
                </div>
            </div>
        </section>

        <section class="article-section">
            <h2>Recursos Adicionales</h2>
            <ul class="resource-list">
                <li><a href="https://www.reactivedesignpatterns.com/" target="_blank">Reactive Design Patterns - Resilience Patterns</a></li>
                <li><a href="https://martinfowler.com/bliki/CircuitBreaker.html" target="_blank">Martin Fowler - Circuit Breaker</a></li>
                <li><a href="https://github.com/resilience4j/resilience4j" target="_blank">Resilience4j Library</a></li>
            </ul>
        </section>
    </div>
}
